"""Assignment 1 - Grocery Store Events

CSC148 Fall 2015, University of Toronto
Instructor: David Liu
Student: Graeme Stroud
Student number: 1002552944
---------------------------------------------

This file should contain all of the classes necessary to model the different
kinds of events in the simulation.
"""

from store import *


class Event:
    """An event.

    Events have an ordering based on the event timestamp in non-ascending
    order. Events with older timestamps are less than those with newer
    timestamps.

    This class is abstract; subclasses must implement do().

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    """
    def __init__(self, timestamp):
        """Initialize an Event with a given timestamp.

        @type self: Event
        @type timestamp: int
            A timestamp for this event.
            Precondition: must be a non-negative integer.
        @rtype: None

        >>> Event(7).timestamp
        7
        """
        self.timestamp = timestamp

    # The following six 'magic methods' are overridden to allow for easy
    # comparison of Event instances. All comparisons simply perform the
    # same comparison on the 'timestamp' attribute of the two events.
    def __eq__(self, other):
        """Return whether this Event is equal to <other>.

        Two events are equal if they have the same timestamp.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first == second
        False
        >>> second.timestamp = first.timestamp
        >>> first == second
        True
        """
        return self.timestamp == other.timestamp

    def __ne__(self, other):
        """Return True iff this Event is not equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first != second
        True
        >>> second.timestamp = first.timestamp
        >>> first != second
        False
        """
        return not self.__eq__(other)

    def __lt__(self, other):
        """Return True iff this Event is less than <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first < second
        True
        >>> second < first
        False
        """
        return self.timestamp < other.timestamp

    def __le__(self, other):
        """Return True iff this Event is less than or equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first <= first
        True
        >>> first <= second
        True
        >>> second <= first
        False
        """
        return self.timestamp <= other.timestamp

    def __gt__(self, other):
        """Return True iff this Event is greater than <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first > second
        False
        >>> second > first
        True
        """
        return not self.__le__(other)

    def __ge__(self, other):
        """Return True iff this Event is greater than or equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first >= first
        True
        >>> first >= second
        False
        >>> second >= first
        True
        """
        return not self.__lt__(other)

    def do(self, store):
        """Perform this Event.

        Call methods on <store> to update its state according to the
        meaning of the event. Note: the "business logic" of what actually
        happens inside a grocery store should be handled in the GroceryStore
        class, not in any Event classes.

        Return a list of new events spawned by this event (making sure the
        timestamps are correct).

        @type self: Event
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        raise NotImplementedError


class AddCustomerEvent(Event):
    """A class that inherits from Event class. Specifically it simulates the
    event of adding a customer to a line.

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    """
    # === Private Attributes ===
    # @type _customer: Customer
    #    The customer being added to the line.
    # === Representation Invariants ===
    # - timestamp must be a non-negative number

    def __init__(self, timestamp, customer):
        """Creates an event that adds a customer to a line in a store.
        @type self: AddCustomerEvent
        @type timestamp: int
            Precondition: must be a non-negative integer.
        @type customer: Customer
        @rtype: None
        """
        self._customer = customer
        super(AddCustomerEvent, self).__init__(timestamp)

    def do(self, store):
        """By doing the event, a customer is added to a line that they are
        eligible to enter.
        @type self: AddCustomerEvent
        @type store: GroceryStore
        @rtype: list[Event]
        """
        generated_events = []

        line = store.add_customer(self._customer)

        # Creates a CheckingOutCustomer Event if the customer is the first and
        # only customer in the line.
        if len(line) == 1:
            checkout_event = CheckingOutCustomerEvent(self.timestamp, line)
            generated_events.append(checkout_event)

        return generated_events

    def __str__(self):
        """Returns a string representation of adding a customer to a line.
        @type self: AddCustomerEvent
        @rtype: str
        >>> c = Customer("Bob", 10)
        >>> e = AddCustomerEvent(10, c)
        >>> str(e)
        "Bob entered a line"

        """
        return "{}: {} entered a line".format(self.timestamp,
                                              self._customer.name)


class CheckingOutCustomerEvent(Event):
    """A class that inherits from Event. It simulates the event of having a
    customer checkout when it is their turn.

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    """
    # === Private Attributes ===
    # @type _line: Line
    #   The line that the customer is checking out of.
    # === Representation Invariants ===
    # - timestamp must be a non-negative number

    def __init__(self, timestamp, line):
        """Initializes an event to have the first customer in line start
        checking out.
        @type timestamp: int
            Precondition: must be a non-negative integer.
        @type line: Line
        @rtype: None
        """
        self._line = line
        super(CheckingOutCustomerEvent, self).__init__(timestamp)

    def do(self, store):
        """Takes the customer with the lowest timestamp and lets them start
        checking out.

        Calculates the time when the checkout is complete, and returns a
        CheckoutCompletedEvent that will occur after that time passes.

        @type self: CheckingOutCustomerEvent
        @type store: GroceryStore
        @rtype: list[CheckOutCompleted]
        """
        finish_checkout_time = self.timestamp + store.\
            first_customer_checkout_time(self._line)

        return [CheckOutCompleted(finish_checkout_time, self._line)]

    def __str__(self):
        """Returns a string representation of a customer checking out event
        @type self: CheckingOutCustomerEvent
        @rtype: str

        """
        customer_name = self._line.get_first_customer().name
        return "{}: {} has begun checking out of a {}".format(self.timestamp,
                                                              customer_name,
                                                              str(self._line))


class CheckOutCompleted(Event):
    """A class that inherits from Event. It specifically takes a customer out of
     a line after the customer has finished checking out and calls event for
     next customer to enter.

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    @type wait_time: int
        The amount of time it took for the customer in the line to checkout.
        The customer in question is the first customer of <_line>.
    """
    # === Private Attributes ===
    # @type _line: Line
    #   The line that the customer is checking out of.
    # === Representation Invariants ===
    # - timestamp must be a non-negative number

    def __init__(self, timestamp, line):
        """Initializes an event to remove first customer and launch event to
        start checking out next customer if applicable.
        @type timestamp: int
            Precondition: must be a non-negative integer.
        @type line: Line
        @rtype: None
        """
        super(CheckOutCompleted, self).__init__(timestamp)
        self._line = line
        self.wait_time = self.timestamp - self._line.get_first_customer().\
            entry_time

    def do(self, store):
        """Lets the event transpire i.e. takes a customer out of the line and
        lets next customer start checking out.

        @type store: GroceryStore
        @rtype: list[]
        """
        # Removes first customer in <_line> since they completed.
        store.checkout_complete(self._line)

        # Next customer starts checking out if there is one.
        if len(self._line) > 0:
            return [CheckingOutCustomerEvent(self.timestamp, self._line)]
        return []

    def __str__(self):
        """Returns a string representation of a completed checkout event
        @type self: CheckOutCompleted
        @rtype: str
        >>> l = CashierLine(10)
        >>> c = Customer('Bob', 10)
        >>> l.add_customer()
        >>> e = CheckOutCompleted(10,l)
        >>> str(e)
        'Bob checked out of a Cashier Line'
        """
        if len(self._line) > 0:
            return "{}: {} checked out of a {}"\
                .format(self.timestamp, self._line.get_first_customer().name,
                        str(self._line))
        else:
            raise IndexError


class CloseLineEvent(Event):
    """A class that inherits from Event. Closes a certain line and moves all the
     customers but the first one into a new line.

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    """
    # === Private Attributes ===
    # @type _index: int
    #   The index of the line that is being closed.
    # === Representation Invariants ===
    # - timestamp must be a non-negative number
    # _index must be a non negative number and less than the the number of open
    #   lines
    def __init__(self, timestamp, index):
        """Initializes an event to close a line at <index>
        @type timestamp: int
            Precondition: must be a non-negative integer.
        @type index: int
        @rtype: None
        """
        self._index = index
        super(CloseLineEvent, self).__init__(timestamp)

    def do(self, store):
        """Call the event of closing a line by putting the customers in a new
         line (except for the one with the lowest timestamp)

         Sets the timestamp of each generated AddCustomerEvent one second apart,
        starting at the timestamp of this event.

        @type store: GroceryStore
        @rtype: List[Event]
        """

        # Returns a list of unattended customers.
        # Last person in line starts at the front of the list. (Since they can
        # get into a new line first)
        unattended_customers = store.close_line(self._index)

        events = []

        for i in range(len(unattended_customers)):
            # The customer's index + the timestamp is their new timestamp.
            # Ex: last customer goes to new line immediately (timestamp + 0)
            #     second last customer goes to new line one second after.
            timestamp = self.timestamp + i
            events.append(AddCustomerEvent(timestamp, unattended_customers[i]))

        return events

    def __str__(self):
        """A string representation of a line closing
        @type self: CloseLineEvent
        @rtype: str
        """
        return "{}: Line #{} has closed".format(self.timestamp, self._index)


def create_event_list(filename):
    """Return a list of Events based on raw list of events in <filename>.

    Precondition: the file stored at <filename> is in the format specified
    by the assignment handout.

    @param filename: str
        The name of a file that contains the list of events.
    @rtype: list[Event]
    """
    events = []
    with open(filename, 'r') as file:
        for line in file:

            tokens = line.split()
            timestamp = int(tokens[0])
            event_type = tokens[1]

            if event_type == 'Arrive':
                name = tokens[2]
                num_items = int(tokens[3])
                events.append(AddCustomerEvent(timestamp, Customer(name,
                                                                   num_items,
                                                                   timestamp)))

            if event_type == 'Close':
                index = int(tokens[2])
                events.append(CloseLineEvent(timestamp, index))

    return events


if __name__ == '__main__':
    import doctest
    doctest.testmod()
